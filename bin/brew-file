#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
Brew-file: Manager for packages of Homebrew
https://github.com/rcmdnk/homebrew-file

requirement: Python 2.7 or later
"""

__prog__ = "brew file"
__author__ = "rcmdnk"
__copyright__ = "Copyright (c) 2013 rcmdnk"
__credits__ = ["rcmdnk"]
__license__ = "MIT"
__version__ = "v2.1.2"
__date__ = "2/Nov/2014"
__maintainer__ = "rcmdnk"
__email__ = "rcmdnk@gmail.com"
__status__ = "Prototype"

import sys, os, urllib2

class Tee:
    def __init__(self, out1, out2 = sys.stdout):
        if type(out1) == str:
            self.out1 = open(out1, "w")
        else:
            self.out1 = out1
        if type(out2) == str:
            self.out2 = open(out2, "w")
        else:
            self.out2 = out2
    def __del__(self):
        if self.out1 != sys.stdout and self.out1 != sys.stderr:
            self.out1.close()
        if self.out2 != sys.stdout and self.out2 != sys.stderr:
            self.out2.close()
    def write(self, text):
        self.out1.write(text)
        self.out2.write(text)
    def writeln(self, text):
        self.out1.write(text + "\n")
        self.out2.write(text + "\n")
    def flush(self):
        self.out1.flush()
        self.out2.flush()

class BrewFile:
    """Main class of Brew-file."""

    def __init__(self):
        """initialization."""
        import re
        cask_opts = {"--caskroom" : ""}
        env_cask_opts = os.environ.get("HOMEBREW_CASK_OPTS", "")
        try:
            if env_cask_opts != "":
                cask_opts.update(dict(map(lambda x: x.split("="),
                                     re.split(r'(?<!\\)\s*', env_cask_opts))))
        except ValueError:
            print "\033[31mHOMEBREW_CASK_OPTS: " + env_cask_opts + " is not a proper format.\033[m"
            print "\033[31mIgnore the value.\n\033[m"

        self.opt = {}

        self.opt["command"]     = ""
        self.opt["brew_repo"]   = self.proc("brew --prefix", False, False)[1][0]
        self.opt["input"]       = os.environ.get("HOMEBREW_BREWFILE",
                                      self.opt["brew_repo"] + "/Library/Brewfile")
        self.opt["brewfile"]    = self.opt["input"]
        self.opt["repo"]        = ""
        self.opt["noupdate"]    = False
        self.opt["link"]        = True
        self.opt["dryrun"]      = True
        self.opt["initialized"] = False
        self.opt["tap_dir"]     = self.opt["brew_repo"] + "/Library/Taps"
        self.opt["cache_dir"]   = self.proc("brew --cache", False, False)[1][0]
        self.opt["caskroom"]    = cask_opts["--caskroom"] \
                                  if cask_opts["--caskroom"] != "" \
                                  else "/opt/homebrew-cask/Caskroom"
        self.opt["cask_pack"]   = "brew-cask"
        self.opt["cask_repo"]   = "caskroom/cask"
        self.opt["pip_pack"]    = "brew-pip"
        self.opt["my_editor"]   = os.environ.get("EDITOR", "vim")
        self.opt["tap_packs"]   = []
        self.opt["tap_casks"]   = []
        self.opt["brew_list"]   = []
        self.opt["pip_list"]    = []
        self.opt["tap_list"]    = []
        self.opt["cask_list"]   = []
        self.opt["cask_list_nocask"] = []
        self.opt["is_brew_cmd"] = False
        self.opt["is_cask_cmd"] = False
        self.opt["is_pip_cmd"]  = False
        self.opt["cmd_input"]   = []
        self.opt["cask_input"]  = []
        self.opt["pip_input"]   = []
        self.opt["tap_input"]   = []
        self.opt["brew_input"]  = []
        self.opt["brew_input_opt"] = []
        self.opt["args"] = []
        self.opt["yn"] = False

    def set_args(self, **kw):
        """Set arguments."""
        for k, v in kw.items():
            self.opt[k] = v

    def proc(self, cmd, print_cmd = True, print_out = True, exit_on_error = True):
        """ Get process output."""
        import subprocess
        if type(cmd) == str:
            cmd = cmd.split()
        if print_cmd:
            print '$', ' '.join(cmd)
        p = subprocess.Popen(cmd, stdout = subprocess.PIPE, stderr = subprocess.STDOUT)
        lines = []
        for l in p.stdout.readlines():
            lines.append(l.rstrip())
            if print_out:
                print l
        ret = p.wait()

        if exit_on_error and ret != 0:
            if not print_out:
                print '\n'.join(lines)
            sys.exit(ret)

        return (ret, lines)

    def ask_yn(self, question):
        """Helper for yes/no."""
        if self.opt["yn"] == True:
            print question + " [y/n]: y"
            return True

        yes = ["yes","y", ""]
        no = ["no","n"]

        yn = raw_input(question + " [y/n]: ").lower()
        while True:
            if yn in yes:
               return True
            elif yn in no:
               return False
            else:
               yn = raw_input("Answer with yes (y) or no (n): ").lower()

    def print_banner(self, text):
        max = 0
        for l in text.split("\n"):
            if max < len(l):
                max = len(l)
        print "\n"
        print "#" * max
        print text
        print "#" * max
        print "\n"

    def remove(self, path):
        """Helper to remove file/directory."""
        import shutil
        if os.path.islink(path) or os.path.isfile(path):
            os.remove(path)
        elif os.path.isdir(path):
            shutil.rmtree(path)

    def get_tap_path(self, tap):
        """Get tap path"""
        tap_user = os.path.dirname(tap)
        tap_repo = os.path.basename(tap)
        return self.opt["tap_dir"] + "/" + tap_user + "/homebrew-" + tap_repo

    def repo_file(self):
        """Helper to build Brewfile path for the repository."""
        repo_name = self.opt["repo"].split("/")[-1].split(".git")[0]
        user_name = self.opt["repo"].split("/")[-2].split(":")[-1]
        inputdir = os.path.dirname(self.opt["input"])
        input = self.opt["input"].split("/")[-1]
        return inputdir + "/" + user_name + "_" + repo_name + "/" + input

    def clone_repo(self):
        ret = self.proc("git clone " + self.opt["repo"] + " "
                        + os.path.dirname(self.opt["brewfile"]),
                        True, True, False)[0]
        if ret != 0:
            print "can't clone " + self.opt["repo"] + ".\n"\
                  "please check the repository, or reset with\n"\
                  "    $ " + __prog__ + " set_repo"
            sys.exit(ret)

    def check_github_repo(self):
        """helper to check and create GitHub repository."""

        import urllib
        import urllib2

        repo_name = self.opt["repo"].split("/")[-1].split(".git")[0]
        user_name = self.opt["repo"].split("/")[-2].split(":")[-1]
        url = "https://github.com/" + user_name + "/" + repo_name

        # Check if the repository already exists or not.
        exist_repo = True
        try:
            check = urllib2.urlopen(url)
        except urllib2.HTTPError, e:
            exist_repo = False

        # Clone if exists
        if exist_repo:
            self.clone_repo()
            return

        # Create new repository
        print "GitHub repository: " + user_name + "/" + repo_name + " doesn't exist."
        ans = self.ask_yn("do you want to create the repository?")
        if not ans:
            exit(0)

        # Check password
        import getpass
        password = getpass.getpass("GitHub password: ")

        # Try to create w/o two-factor code
        import requests, json
        url = "https://api.github.com/user/repos"
        description = "package list for Homebrew"
        data = {"name": repo_name, "description": "Package list for Homebrew",
                "auto_init": "true"}
        headers = {}
        is_ok = True
        while True:
            r = requests.post(url=url, data=json.dumps(data),
                              auth=(user_name, password), headers=headers)
            if r.ok:
                break
            if r.json()["message"] == "Bad credentials":
                password = getpass.getpass("\033[31;1mWrong password!\033[0m GitHub password: ")
                continue
            if r.json()["message"] == "Must specify two-factor authentication OTP code.":
                is_ok = False
                break
            print r.json()["message"]
            sys.exit(1)

        if not is_ok:
            # Try with two-factor code
            twofac = raw_input("GitHub two-factor code: ")
            headers.update({"X-Github-OTP": twofac})
            while True:
                r = requests.post(url=url, data=json.dumps(data),
                                  auth=(user_name, password), headers=headers)
                if r.ok:
                    break
                if r.json()["message"] == "Must specify two-factor authentication OTP code.":
                    twofac = getpass.getpass("\033[31;1mWrong code!\033[0m GitHub two-factor code: ")
                    headers.update({"X-Github-OTP": twofac})
                    continue
                print r.json()["message"]
                sys.exit(1)

        # Clone and initialize
        self.clone_repo()
        os.chdir(os.path.dirname(self.opt["brewfile"]))
        f = open("README.md", "w")
        f.write("# " + repo_name + "\n\n"\
                "Package list for [homebrew](http://brew.sh/).\n\n"\
                "Managed by [homebrew-file](https://github.com/rcmdnk/homebrew-file).")
        f.close()
        open(self.opt["brewfile"], "a").close()

        ret = self.proc("git add -A")[0]
        ret = self.proc(["git", "commit", "-m", "\"Prepared by " + __prog__ + "\""])[0]
        ret = self.proc("git push")[0]

        ans = self.ask_yn("Do you want to initialize from installed packages?")
        if ans:
            self.initialize(False)

    def check_repo(self):
        """Check input file for GitHub repository."""
        import re

        # Check input file
        if not os.path.exists(self.opt["input"]):
            return

        # Check input file if it points repository or not
        self.opt["repo"] = ""
        f = open(self.opt["input"], "r")
        lines = f.readlines()
        f.close()
        for l in lines:
            if re.match(" *git ", l) == None:
                continue
            git_line = l.split()
            if len(git_line) > 1:
                self.opt["repo"] = git_line[1]
                break
        if self.opt["repo"] == "":
            return

        # Check repository name and add git@github.com: if necessary
        if (re.match("git://", self.opt["repo"]) == None
                and re.match("git@", self.opt["repo"]) == None
                and re.match("https?://", self.opt["repo"]) == None):
            self.opt["repo"] = "git@github.com:" + self.opt["repo"]

        # Set Brewfile in the repository
        self.opt["brewfile"] = self.repo_file()
        if os.path.exists(self.opt["brewfile"]):
            return

        # Check and prepare repository
        if self.opt["repo"].find("github") >= 0:
            self.check_github_repo()
        else:
            self.clone_repo()

    def repomgr(self, cmd=""):
        """Helper of repository management."""
        pull = False
        push = False
        if cmd == "pull":
            pull = True
            push = False
        elif cmd == "push":
            pull = False
            push = True

        # Check the repository
        if self.opt["repo"] == "":
            print "Please set a repository, or reset with:"
            print "    $ " + __prog__ + "set_repo\n"
            sys.exit(1)

        # Clone if it doesn't exist
        if not os.path.exists(os.path.dirname(self.opt["brewfile"])):
            self.clone_repo()


        # pull/push
        print "cd", os.path.dirname(self.opt["brewfile"])
        os.chdir(os.path.dirname(self.opt["brewfile"]))
        if pull:
            ret = self.proc("git pull")[0]
            return
        elif push:
            ret = self.proc("git add " + self.opt["brewfile"].split("/")[-1])[0]
            ret = self.proc(["git", "commit", "-m", "\"Update the package list\""])[0]
            ret = self.proc("git push")[0]
            return

    def get_tap(self, tap):
        """Helper for tap configuration file"""
        tap_path = self.get_tap_path(tap)
        if not os.path.isdir(tap_path):
            return
        self.opt["tap_packs"] = map(lambda x: x.replace(".rb", ""),
                filter(lambda y: y.endswith(".rb"), os.listdir(tap_path)))
        path = tap_path + "/Formula"
        if os.path.isdir(path):
            self.opt["tap_packs"] += map(lambda x: x.replace(".rb", ""),
                    filter(lambda y: y.endswith(".rb"),
                           os.listdir(path)))
        path = tap_path + "/Casks"
        if os.path.isdir(path):
            self.opt["tap_casks"] = map(lambda x: x.replace(".rb", ""),
                    filter(lambda y: y.endswith(".rb"),
                           os.listdir(tap_path + "/Casks")))

    def check_brew_cmd(self):
        """Check Homebrew"""
        if self.proc("brew help", False, False, False)[0] != 0:
            print "Homebrew has not been installed, install now..."
            cmd="ruby -e \"$(curl -fsSL https://raw.github.com/Homebrew/homebrew/go/install)\""
            self.proc(cmd)
            (ret, lines) =  self.proc("brew doctor", True, True, False)
            if ret != 0:
                self.print_banner("# Check brew environment and fix problems\n"
                                  "# You can check with:\n"
                                  "#     $ brew doctor")

    def check_cask_cmd(self, force=False):
        """Check cask is installed or not"""
        if self.opt["is_cask_cmd"]:
            return True
        if self.proc("brew cask", False, False, False)[0] == 0:
            self.opt["is_cask_cmd"] = True
            return True
        if force:
            print self.opt["cask_pack"]\
                    + " has not been installed, install now."
            ret = self.proc(["brew", "install",
                    self.opt["cask_repo"] + "/" + self.opt["cask_pack"]],
                    True, True, False)[0]
            if ret != 0:
                print "\n\033[31;1mFailed to install "\
                        + self.opt["cask_pack"] + "\033[0m\n"
                print list
                sys.exit(ret)
            if not self.opt["cask_repo"] in self.opt["tap_list"]:
                self.opt["tap_list"].append(self.opt["cask_repo"])
            if not self.opt["cask_pack"] in self.opt["brew_list"]:
                self.opt["brew_list"].append(self.opt["cask_pack"])
            self.opt["is_cask_cmd"] = True
        return self.opt["is_cask_cmd"]

    def check_pip_cmd(self, force=False):
        """Check pip is installed or not"""
        if self.opt["is_pip_cmd"]:
            return True
        if self.proc("brew pip -h", False, False, False)[0] == 0:
            self.opt["is_pip_cmd"] = True
            return True
        if force:
            print self.opt["pip_pack"]\
                    + " has not been installed, install now."
            ret = self.proc(["brew", "install", self.opt["pip_pack"]],
                            True, True, False)[0]
            if ret != 0:
                print "\n\033[31;1mFailed to install "\
                        + self.opt["pip_pack"] + "\033[0m\n"
                print list
                sys.exit(ret)
            if not self.opt["pip_pack"] in self.opt["brew_list"]:
                self.opt["brew_list"].append(self.opt["pip_pack"])
            self.opt["is_pip_cmd"] = True
        return self.opt["is_pip_cmd"]

    def get_list(self):
        """Get List"""

        # Brew packages
        (ret, lines) = self.proc("brew list", False, False)
        self.opt["brew_list"] = []
        self.opt["pip_list"] = []
        for p in lines:
            if p.startswith("pip-"):
                self.opt["pip_list"].append(p)
            else:
                self.opt["brew_list"].append(p)

        # Taps
        (ret, lines) = self.proc("brew tap", False, False)
        self.opt["tap_list"] = lines

        # Casks
        if self.check_cask_cmd():
            (ret, lines) = self.proc("brew cask list", False, False)
            self.opt["cask_list"] = []
            self.opt["cask_list_nocask"] = []
            for p in lines:
                if len(p.split()) == 1:
                    self.opt["cask_list"].append(p)
                else:
                    print "\033[31;1mthe cask file of \033[31;7m" + p + "\033[0m\033[31;1m doesn't exist."
                    print "please check later.\n\n\033[0m"
                    self.opt["cask_list_nocask"].append(p)

    def read_input(self):
        """Read input file"""

        # Check packages in the input file
        self.opt["cmd_input"]   = []
        self.opt["cask_input"]  = []
        self.opt["pip_input"]   = []
        self.opt["tap_input"]   = []
        self.opt["brew_input"]  = []
        self.opt["brew_input_opt"] = []

        f = open(self.opt["brewfile"], "r")
        lines = f.readlines()
        f.close()
        import re
        for l in lines:
            if re.match(" *$", l) != None or re.match(" *#", l) != None:
                continue
            args = l.replace("'","").replace('"',"").split()
            cmd = args[0]
            if len(args) < 2:
                print "\n\033[31;1mWrong line: " + l + "\033[0m"
                continue
            p = args[1]
            if len(args) > 2 and p == "install":
                p = args[2]
                args.pop(2)

            opt = " ".join(args[2:])

            if cmd == "brew" or cmd == "install":
                self.opt["brew_input"].append(p)
                self.opt["brew_input_opt"].append((p + " " + opt).strip())
            elif cmd == "tap":
                self.opt["tap_input"].append(p)
            elif cmd == "tapall":
                self.opt["tap_input"].append(p)
                self.get_tap(p)
                self.opt["brew_input"] += self.opt["tap_packs"]
            elif cmd == "cask":
                self.opt["cask_input"].append(p)
            elif cmd == "pip":
                self.opt["pip_input"].append(p)
            else:
                self.opt["cmd_input"].append(l.strip())
                continue

    def set_brewfile_repo(self):
        """Set Brewfile repository"""
        import re

        # Check input file
        if os.path.exists(self.opt["input"]):
            prev_repo = ""
            f = open(self.opt["input"], "r")
            lines = f.readlines()
            f.close()
            for l in lines:
                if re.match(" *git ", l) == None:
                    continue
                git_line = l.split()
                if len(git_line) > 1:
                    prev_repo = git_line[1]
                    break
            print "Input file: " + self.opt["input"] + " is already there."
            if prev_repo != "":
                print "git repository for Brewfile is already set as " + prev_repo

            ans = self.ask_yn("Do you want to overwrite it?")
            if ans:
                os.rename(self.opt["input"], self.opt["input"] + ".bak")
                print "Ok, old input file was moved to " + self.opt["input"] + ".bak."
            else:
                sys.exit(0)

        # Get repository
        if self.opt["repo"] == "":
            print "Set repository, \"non\" for local Brewfile,"
            print "<user>/<repo> for github repository,"
            self.opt["repo"] = raw_input("or full path for the repository: ")
            while True:
                if self.opt["repo"] != "":
                    break
                print "Repository can not be empty"
                self.opt["repo"] = raw_input("Set repository: ")
            self.print_banner("# Set Brewfile repository as " + self.opt["repo"])

        if self.opt["repo"] == "non":
            # Reset non repository type Brewfile
            self.initialize(False)
            return
        else:
            # Write repository to the input file
            f = open(self.opt["input"], "w")
            f.write("git " + self.opt["repo"])
            f.close()
            self.check_repo()

    def get_options(self, package):
        """get install options from brew info"""

        opt=""
        # Get options for build
        (ret, lines) = self.proc("brew info " + package, False, False)
        versions = {"stable":"", "devel":"", "HEAD":""}
        v_tmp = map(lambda x: x.strip().split(),
                    lines[0].split(":")[1].split(","))
        for v in v_tmp:
            if v[0] == "stable":
                versions["stable"] = v[1]
            elif v[0] == "devel":
                versions["devel"] = v[1]
            elif v[0] == "HEAD":
                versions["HEAD"] = "HEAD"
        cellar = self.proc("brew --cellar " + package, False, False)[1][0]
        for l in lines:
            ltmp = l.split("Built from source with: ")
            if len(ltmp) > 1:
                opt += " " + ltmp[1].replace(",", "")
                continue
            if l.startswith(cellar):
                v = l.split()[0].split("/")[-1]
                for k in versions.keys():
                    if v == versions[k]:
                        if k != "stable":
                            opt += " --" + k
                        break
        return opt

    def initialize(self, check = True):
        """Initialize Brewfile"""
        if self.opt["initialized"]:
            return

        if check == 1:
            if not os.path.exists(self.opt["input"]):
                ans = self.ask_yn("Do you want to set a repository (y)? ((n) for local Brewfile).")
                if ans:
                    self.set_brewfile_repo()
                    return
            else:
                if self.opt["repo"] != "":
                    print "You are using Brewfile of " + self.opt["repo"] + "."
                else:
                    print self.opt["input"] + " is already there."

                ans = self.ask_yn("Do you want to overwrite it?")
                if ans:
                    if self.opt["repo"] == "":
                        os.rename(self.opt["input"], self.opt["input"] + ".bak")
                        print "Ok, old input file was moved to " + self.opt["input"] + ".bak."
                else:
                    sys.exit(0)

        self.print_banner("# Initialize " + self.opt["brewfile"])

        # Get installed package list
        self.get_list()

        # Check list
        out = Tee(self.opt["brewfile"])

        # Taps
        if len(self.opt["tap_list"]) > 0:
            out.writeln("# tap repositories and their packages")
            for p in self.opt["tap_list"]:
                self.get_tap(p)
                out.writeln("\n## " + p + "\ntap " + p)
                for tp in self.opt["tap_packs"]:
                    if tp in self.opt["brew_list"]:
                        opt = self.get_options(tp)
                        out.writeln("install " + tp + opt)
                        self.opt["brew_list"].remove(tp)
                for tc in self.opt["tap_casks"]:
                    if tc in self.opt["cask_list"]:
                        out.writeln("cask install " + tc)
                        self.opt["cask_list"].remove(tc)

        # Brew packages
        if len(self.opt["brew_list"]) > 0:
            out.writeln("\n# Other Homebrew packages")
            for p in self.opt["brew_list"]:
                opt = self.get_options(p)
                out.writeln("install " + p + opt)

        # pip packages
        if len(self.opt["pip_list"]) > 0:
            out.writeln("\n# pip packages")
            for p in self.opt["pip_list"]:
                #opt = self.get_options(p)
                opt = ""
                out.writeln("pip " + p + opt)

        # Casks
        if len(self.opt["cask_list"]) > 0:
            out.writeln("\n# Cask applications")
            for p in self.opt["cask_list"]:
                #opt = self.get_options(p)
                opt = ""
                out.writeln("cask install " + p + opt)

        # Installed by cask, but cask files were not found...
        if len(self.opt["cask_list_nocask"]) > 0:
            out.writeln("\n# Below applications were installed by Cask,")
            out.writeln("but not corresponding casks were found.\n")
            for p in self.opt["cask_list_nocask"]:
                #opt = self.get_options(p)
                opt = ""
                out.writeln("#cask  install " + p + opt)

        # Close Brewfile
        del out

        self.print_banner("# You can edit " + self.opt["brewfile"] + " with:\n"
                          "#     $ " + __prog__ + " edit")

        self.opt["initialized"] = True

    def check_input_file(self):
        """Check input file"""

        if not os.path.exists(self.opt["brewfile"]):
            print "WARNING: Input file $brewfile is not found."
            ans = self.ask_yn("WARNING: Do you want to initialize from installed packages?")
            if ans:
                self.initialize(False)
                return
            else:
                print "WARNING: Ok, please prepare brewfile"
                print "WARNING: or you can initialize " + self.opt["brewfile"] + " with:"
                print "WARNING:     $ " + __prog__ + " init"
                sys.exit(1)

    def edit_brewfile(self):
        """Edit brewfile"""
        import subprocess
        subprocess.call([self.opt["my_editor"], self.opt["brewfile"]])

    def cleanup(self):
        """Clean up."""
        if self.opt["dryrun"]:
            self.print_banner("# Dry run")

        # Check up packages in the input file
        self.read_input()

        # Clean up cask packages
        if len(self.opt["cask_list"]) > 0:
            self.print_banner("# Clean up cask packages")
            for p in self.opt["cask_list"]:
                if p in self.opt["cask_input"]:
                    continue
                self.check_cask_cmd(True)
                cmd = "brew cask uninstall " + p
                print cmd
                if not self.opt["dryrun"]:
                    self.proc(cmd, False, True)
                self.opt["cask_list"].remove(p)
        # Skip clean up cask at tap/brew if any cask packages exist
        if len(self.opt["cask_list"]) > 0:
            self.opt["tap_list"].remove(self.opt["cask_repo"])
            self.opt["brew_list"].remove(self.opt["cask_pack"])

        # Clean up pip packages
        if len(self.opt["pip_list"]) > 0:
            self.print_banner("# Clean up pip packages")
            for p in self.opt["pip_list"]:
                if p in self.opt["pip_input"]:
                    continue
                cmd0 = "pip uninstall -y " + p
                cmd1 = "brew uninstall " + p
                cmd2 = "brew uninstall pip-" + p
                print cmd0
                if not self.opt["dryrun"]:
                    self.proc(cmd0, False, True)
                print cmd1
                if not self.opt["dryrun"]:
                    self.proc(cmd1, False, True)
                print cmd2
                if not self.opt["dryrun"]:
                    self.proc(cmd2, False, True)
                self.opt["pip_list"].remove(p)
        # Skip clean up cask at tap/brew if any cask packages exist
        if len(self.opt["pip_list"]) > 0:
            self.opt["tap_list"].remove(self.opt["pip_repo"])
            self.opt["brew_list"].remove(self.opt["pip_pack"])

        # Clean up tap packages
        if len(self.opt["tap_list"]) > 0:
            self.print_banner("# Clean up tap packages")
            for p in self.opt["tap_list"]:
                if p in self.opt["tap_input"]:
                    continue
                self.get_tap(p)
                untapflag = True
                for tp in self.opt["tap_packs"]:
                    if tp in self.opt["brew_input"]:
                        # Keep the Tap as related package is remained
                        untapflag = False
                        break
                if not untapflag:
                    continue
                cmd = "brew untap " + p
                print cmd
                if not self.opt["dryrun"]:
                    self.proc(cmd, False, True)

        # Clean up brew packages
        if len(self.opt["brew_list"]) > 0:
            self.print_banner("# Clean up brew packages")
            for p in self.opt["brew_list"]:
                if p in self.opt["brew_input"]:
                    continue
                cmd = "brew uninstall " + p
                print cmd
                if not self.opt["dryrun"]:
                    (ret, lines) = self.proc("brew info " + p, False, False)
                    for l in lines:
                        if l.find("ln -s") >= 0:
                            if len(l.split()) > 2:
                                app = l.split()[2]
                                break
                    #self.remove("/Applications/" + app)
                    #self.remove("/Applications/Utilities/" + app)
                    #self.remove(os.environ["HOME"] + "/Applications/" + app)
                    #self.remove(os.environ["HOME"] + "/Applications/Utilities/" + app)

                    self.proc(cmd, False, True)

        # Clean up cashe
        self.print_banner("# Clean up cache")
        cmd0 = "brew cleanup --force"
        cmd1 = "rm -rf " + self.opt["cache_dir"]
        print cmd0
        if not self.opt["dryrun"]:
            self.proc(cmd0, False)
        print cmd1
        if not self.opt["dryrun"]:
            self.proc(cmd1, False)
        else:
            # Dry run message
            self.print_banner("# This is dry run.\n"
                              "# If you want to enforce cleanup, use '-C':\n"
                              "#     $ " + __prog__ + " clean -C")

    def install(self):
        """Install"""
        # First update Homebrew
        if not self.opt["noupdate"]:
            self.proc("brew update")

        # Check packages in the input file
        self.read_input()

        # Tap
        for p in self.opt["tap_input"]:
            if not p in self.opt["tap_list"]:
                self.proc("brew tap " + p)

        # Cask
        for p in self.opt["cask_input"]:
            if not p in self.opt["cask_list"]:
                self.check_cask_cmd(True)
                self.proc("brew cask install " + p)

        # pip
        for p in self.opt["pip_input"]:
            if not p in self.opt["pip_list"]:
                self.check_pip_cmd(True)
                self.proc("brew pip " + p)

        # Brew
        for p in self.opt["brew_input_opt"]:
            if not p.split()[0] in self.opt["brew_list"]:
                (ret, lines) = self.proc("brew install " + p)
                for l in lines:
                    if l.find("ln -s") >= 0:
                        if self.opt["link"]:
                            self.proc(l)
                    if l.find("brew linkapps") >= 0:
                        if self.opt["link"]:
                            self.proc("brew linkapps")

        # Other commands
        for c in self.opt["cmd_input"]:
            self.proc(c)
            if ret != 0:
                print c + ": returned error:\n\n" + list
                sys.exit(ret)

        return 0

    def find_app(self, app, taps):
        """Helper function for Cask"""
        self.check_cask_cmd(True)
        [cask_user, cask_repo_name] = self.opt["cask_repo"].split("/")
        cask_namer = self.get_tap_path(self.opt["cask_repo"])\
                     + "/developer/bin/cask_namer"
        name = ""
        lines = self.proc([cask_namer, '"' + app + '"'] , False, False, False)[1]
        for l in lines:
            if l.find("Proposed Cask name") >= 0:
                name = l.split()[3]

        tap = ""
        installed = False
        if name != "":
            for t in taps:
                d = self.get_tap_path(t) + "/Casks"
                if os.path.exists(d + "/" + name + ".rb"):
                    tap = t
                    lines = self.proc("brew cask info " + name, False, False)[1]
                    installed =True
                    for l in lines:
                        if l.find("Not installed") >= 0:
                            installed = False
                            break
                    break
        if not installed:
            name = ""
            for t in taps:
                d = self.get_tap_path(t) + "/Casks"
                for n in map(lambda x: x.replace(".rb", ""),
                        filter(lambda y: y.endswith(".rb"), os.listdir(d))):
                    f = open(d + "/" + n + ".rb", "r")
                    content = f.read()
                    f.close()
                    if content.find(app) >= 0:
                        lines = self.proc("brew cask info " + n, False, False)[1]
                        installed =True
                        for l in lines:
                            if l.find("Not installed") >= 0:
                                installed = False
                                break
                        tap = t
                        name = n
        if name == "":
            print "Non Cask app:", app
        elif installed:
            print "Installed by Cask:", app, name
        else:
            print "Installed directly, instead of by Cask:", app, name
        return (tap, installed, name)

    def check_cask(self):
        """Check applications for Cask"""
        self.check_cask_cmd(True)

        print "Starting to check applications for Cask..."

        # Set cask directories and reset application information list
        taps = filter(lambda t: os.path.isdir(self.get_tap_path(t) + "/Casks"),
                      self.proc("brew tap", False, False)[1])
        apps = dict([d,{True:[], False:[]}] for d in taps + [""])

        # Set applications directories
        app_dirs = [d for d in ["/Applications", "/Applications/Utilities",
                os.environ["HOME"] + "/Applications",
                os.environ["HOME"] + "/Applications/Utilities"]
                if os.path.isdir(d)]
        apps_check = {"cask": dict([d, 0] for d in app_dirs),
                      "has_cask": dict([d, 0] for d in app_dirs),
                      "no_cask": dict([d, 0] for d in app_dirs)}

        # Get applications
        napps = 0
        for d in app_dirs:
            for app in filter(lambda x: x.endswith(".app"), os.listdir(d)):
                (tap, installed, name) = self.find_app(app, taps)
                apps[tap][installed].append((name, d + "/" + app))
                check = "no_cask"
                if installed:
                    check = "cask"
                elif name != "":
                    check = "has_cask"
                apps_check[check][d] += 1
                napps += 1

        # Make list
        out = Tee("Caskfile")

        out.writeln("# Cask applications")
        out.writeln("# Please copy these lines to your Brewfile"
                    " and use with `" + __prog__ + " install`.\n")

        if apps.has_key(self.opt["cask_repo"]):
            out.writeln("# Main tap repository for " + self.opt["cask_pack"])
            out.writeln("tap " + self.opt["cask_repo"])
            out.writeln("install " + self.opt["cask_pack"])
            out.writeln("")
            out.writeln("# Apps installed by Cask in " + self.opt["cask_pack"])
            for (name,app_path) in apps[self.opt["cask_repo"]][True]:
                    out.writeln("cask install " + name
                                + " #" + app_path.replace(os.environ["HOME"], "~"))
            out.writeln("")

            out.writeln("# Apps installed directly instead of by Cask in " + self.opt["cask_pack"])
            for (name,app_path) in apps[self.opt["cask_repo"]][False]:
                    out.writeln("#cask install " + name
                                + " #" + app_path.replace(os.environ["HOME"], "~"))
            out.writeln("")

        for t in filter(lambda x: x != self.opt["cask_repo"] and x != "", taps):
            out.writeln("# Casks in " + t)
            out.writeln("tap " + t)
            out.writeln("")
            out.writeln("# Apps installed by Cask in " + t)
            for (name,app_path) in apps[t][True]:
                    out.writeln("cask install " + name
                                + " #" + app_path.replace(os.environ["HOME"], "~"))
            out.writeln("")

            out.writeln("# Apps installed directly instead of by Cask in " + t)
            for (name,app_path) in apps[t][False]:
                    out.writeln("#cask install " + name
                                + " #" + app_path.replace(os.environ["HOME"], "~"))
            out.writeln("")

        out.writeln("# Apps installed but no casks are available")
        for (name,app_path) in apps[""][False]:
                out.writeln("#" + app_path)

        del out

        # Summary
        self.print_banner("# Summary")
        print "Total:", napps, "apps have been checked."
        print "Apps in", app_dirs
        print ""
        maxlen = max(len(x.replace(os.environ["HOME"], "~")) for x in app_dirs)
        print "Installed by Cask:"
        for d in app_dirs:
            print "{0:<{1}s} : {2:d}".format(d.replace(
                    os.environ["HOME"], "~"), maxlen, apps_check["cask"][d])
        print ""
        print "Installed directly, but casks are available:"
        for d in app_dirs:
            print "{0:<{1}s} : {2:d}".format(d.replace(
                    os.environ["HOME"], "~"), maxlen, apps_check["has_cask"][d])
        print ""
        print "No casks"
        for d in app_dirs:
            print "{0:<{1}s} : {2:d}".format(d.replace(
                    os.environ["HOME"], "~"), maxlen, apps_check["no_cask"][d])
        print ""

    def cask_upgrade(self):
        """Upgrade cask applications"""
        if not self.check_cask_cmd():
            return
        apps = self.proc("brew cask list", False, False)[1]
        for a in apps:
            lines = self.proc("brew cask info " + a, False, False)[1]
            installed =True
            for l in lines:
                if l.find("Not installed") >= 0:
                    installed = False
                    break
            if not installed:
                self.proc(["brew", "cask", "install", a])
            if not self.opt["dryrun"]:
                current = ""
                for l in lines:
                    if l.startswith(self.opt["caskroom"]):
                        current = l.split()[0]
                if current == "":
                    continue
                appdir = os.path.dirname(current)
                for d in os.listdir(appdir):
                    if d != current.split("/")[-1]:
                        print "rm -rf " + appdir + "/" + d
                        self.remove(appdir + "/" + d)



    def execute(self):
        """Main execute function"""

        # Check Homebrew
        self.check_brew_cmd()

        # Cask list check
        if self.opt["command"] == "casklist":
            self.check_cask()
            sys.exit(0)

        # Upgrade cask applications
        if self.opt["command"] == "cask_upgrade":
            self.cask_upgrade()
            sys.exit(0)

        # Set BREWFILE repository
        if self.opt["command"] == "set_repo":
            self.set_brewfile_repo()
            sys.exit(0)

        # Change brewfile if it is repository's one.
        self.check_repo()

        # Do pull/push for the repository.
        if self.opt["command"] in ["pull", "push"]:
            self.repomgr(self.opt["command"])
            sys.exit(0)

        # brew command
        if self.opt["command"] == "brew":
            noinit = False
            if len(self.opt["args"]) > 0:
                if self.opt["args"] == "noinit":
                    noinit = True
                    self.opt["args"].pop(0)
            (ret, lines) = self.proc(["brew"] + self.opt["args"], True, True, False)
            if ret != 0 or noinit:
                sys.exit(ret)
            self.initialize(False)
            sys.exit(0)

        # Initialize
        if self.opt["command"] == "init":
            self.initialize()
            sys.exit(0)

        # Check input file
        # If the file doesn't exist, initialize it.
        self.check_input_file()

        # Edit
        if self.opt["command"] == "edit":
            self.edit_brewfile()
            sys.exit(0)

        # Get list for cleanup/install
        self.get_list()

        # Cleanup
        if self.opt["command"] == "clean":
            self.cleanup()
            sys.exit(0)

        # Install
        if self.opt["command"] == "install":
            self.install()
            sys.exit(0)

        # Update
        if self.opt["command"] == "update":
            if self.opt["repo"] != "":
                self.repomgr("pull")
            self.install()
            self.proc("brew upgrade")
            self.initialize(False)
            if self.opt["repo"] != "":
                self.repomgr("push")
                self.opt["dryrun"] = False
                self.cleanup()
            sys.exit(0)

def main():
    # Prepare BrewFile
    b = BrewFile()

    import argparse

    # Pre Parser
    pre_parser = argparse.ArgumentParser(add_help=False, usage= __prog__  + "...")
    group = pre_parser.add_mutually_exclusive_group()
    group.add_argument("-i", "--init", action="store_const",
                       dest="command", const="init")
    group.add_argument("-s", "--set_repo", action="store_const",
                       dest="command", const="set_repo")
    group.add_argument("-c", "--clean", action="store_const",
                       dest="command", const="clean")
    group.add_argument("-u", "--update", action="store_const",
                       dest="command", const="update")
    group.add_argument("-e", "--edit", action="store_const",
                       dest="command", const="edit")
    group.add_argument("-v", "--version", action="store_const",
                       dest="command", const="version")
    group.add_argument("-h", "--help", action="store_const",
                       dest="command", const="help")

    # Parent parser
    file_parser = argparse.ArgumentParser(add_help=False)
    file_parser.add_argument("-f", "--file", action="store", dest="input",
            default=b.opt["input"],
            help="Set input file (default: %(default)s). \n"
                  "You can set input file by environmental variable,\n"
                  "HOMEBREW_BREWFILE, like:\n"
                  "    export HOMEBREW_BREWFILE=~/.brewfile")

    noupdate_parser = argparse.ArgumentParser(add_help=False)
    noupdate_parser.add_argument("-U", "--noupdate", action="store_true",
            default=False, dest="noupdate",
            help="Do not execute update in install or other commands.")

    repo_parser = argparse.ArgumentParser(add_help=False)
    repo_parser.add_argument("-r", "--repo", action="store", default="", dest="repo",
            help="Set repository name. Use with set_repo.")

    link_parser = argparse.ArgumentParser(add_help=False)
    link_parser.add_argument("-n", "--nolink", action="store_false", default=True,
            dest="link", help="Don't make links for Apps.")

    dryrun_parser = argparse.ArgumentParser(add_help=False)
    dryrun_parser.add_argument("-C", action="store_false", default=True,
            dest="dryrun", help="Run cleanup in non dry-run mode.")

    yn_parser = argparse.ArgumentParser(add_help=False)
    yn_parser.add_argument("-y", "--yes", action="store_true", default=False,
            dest="yn", help="Answer yes to all yes/no questions.")

    subparser_options = {"parents":[file_parser, yn_parser, noupdate_parser],
            "formatter_class": argparse.RawTextHelpFormatter}

    # Main parser
    parser = argparse.ArgumentParser(add_help=False, prog=__prog__,
            parents=[file_parser, repo_parser, link_parser, dryrun_parser],
            formatter_class = argparse.RawTextHelpFormatter,
            description = "Brew-file: Manager for packages of Homebrew\n"
                          "https://github.com/rcmdnk/homebrew-file")

    subparsers = parser.add_subparsers(
            title="subcommands", metavar="[command]", help="", dest="command")

    help="Install packages in BREWFILE (do 'brew update', too).\n"\
         "-U not to execute brwe update."
    install_parser = subparsers.add_parser("install", description=help, help=help,
            **subparser_options)
    help="Execute brew command, and update BREWFILE."
    brew_parser = subparsers.add_parser("brew", description=help, help=help,
            parents=[file_parser, yn_parser],
            formatter_class=argparse.RawTextHelpFormatter)
    help="or -i/--init\nInitialize/Update BREWFILE with installed packages."
    init_parser = subparsers.add_parser("init", description=help, help=help,
            parents=[file_parser, link_parser, yn_parser, noupdate_parser],
            formatter_class=argparse.RawTextHelpFormatter)
    help="or -s/--set_repo\nSet BREWFILE repository (e.g. rcmdnk/Brewfile)."
    set_repo_parser = subparsers.add_parser("set_repo", description=help, help=help,
            parents=[file_parser, repo_parser, yn_parser],
            formatter_class=argparse.RawTextHelpFormatter)
    help="Update BREWFILE from the repository."
    pull_parser = subparsers.add_parser("pull", description=help, help=help,
            **subparser_options)
    help="Push your BREWFILE to the repository."
    push_parser = subparsers.add_parser("push", description=help, help=help,
            **subparser_options)
    help="or -c/--clean\nCleanup.\n"\
         "Uninstall packages not in the list.\n"\
         "Untap packages not in the list.\n"\
         "Cleanup cache (brew cleanup)\n"\
         "By drault, cleanup runs as dry-run.\n"\
         "If you want to enforce cleanup, use '-C' option."
    clean_parser = subparsers.add_parser("clean", description=help, help=help,
            parents=[file_parser, dryrun_parser, yn_parser],
            formatter_class=argparse.RawTextHelpFormatter)
    help="or -u/--update\nDo pull, install, brew update/upgrade, init,\n"\
         "push and clean -C.\n"\
         "In addition, pull, push and clean\n"\
         "will be done if the repository is assigned."
    update_parser = subparsers.add_parser("update", description=help, help=help,
            parents=[file_parser, link_parser, yn_parser, noupdate_parser],
            formatter_class=argparse.RawTextHelpFormatter)
    help="or -e/--edit\nEdit input file."
    edit_parser = subparsers.add_parser("edit", description=help, help=help,
            **subparser_options)
    help="Check applications for Cask."
    casklist_parser = subparsers.add_parser("casklist", description=help, help=help,
            formatter_class = argparse.RawTextHelpFormatter)
    help="Upgrade cask applications.\n"\
         "With -C, old versions will be removed."
    cask_upgrade_parser = subparsers.add_parser("cask_upgrade", description=help,
            help=help, parents=[dryrun_parser, yn_parser],
            formatter_class = argparse.RawTextHelpFormatter)
    help="or -v/--version\nShow version."
    version_parser = subparsers.add_parser("version", description=help, help=help,
            formatter_class=argparse.RawTextHelpFormatter)
    help="or -h/--help\nPrint Help (this message) and exit."
    help_parser = subparsers.add_parser("help", description=help, help=help,
            formatter_class=argparse.RawTextHelpFormatter)

    if len(sys.argv) == 1:
        parser.print_usage()
        print ""
        print "Execute `" + __prog__ + " help` for more information."
        sys.exit(1)

    (ns, args) = pre_parser.parse_known_args()
    if ns.command != None:
        args = [ns.command] + args

    (ns, args_tmp) = parser.parse_known_args(args)
    args = vars(ns)
    args.update({'args': args_tmp})

    b.set_args(**args)

    if b.opt["command"] == "help":
        parser.print_help()
        sys.exit(0)
    if b.opt["command"] == "version":
        print __prog__ + " " + __version__ + " " + __date__
        sys.exit(0)

    b.execute()

if __name__ == "__main__":
    main()
